<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PRO AI Bot Builder Installer</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/tweetnacl/1.0.3/nacl.min.js"></script>

<style>
body{background:#0f1115;color:#fff;font-family:monospace;padding:20px}
input,textarea{width:100%;margin:6px 0;padding:10px;background:#1a1d24;border:1px solid #333;color:#fff}
button{padding:12px;background:#00ff99;border:none;font-weight:bold;cursor:pointer;margin-top:10px}
#log{background:#000;padding:10px;height:280px;overflow:auto;margin-top:15px}
</style>
</head>
<body>

<h2>ðŸš€ PRO AI Telegram Bot Builder (FINAL)</h2>

<input id="gh" placeholder="GitHub PAT (repo + workflow)">
<input id="repo" placeholder="Repository name">

<textarea id="tokens" placeholder="Telegram tokens (ÐºÐ°Ð¶Ð´Ñ‹Ð¹ Ñ Ð½Ð¾Ð²Ð¾Ð¹ ÑÑ‚Ñ€Ð¾ÐºÐ¸)"></textarea>

<input id="openrouter" placeholder="OpenRouter API Key">

<textarea id="prompts" placeholder="System prompts (ÐºÐ°Ð¶Ð´Ñ‹Ð¹ Ñ Ð½Ð¾Ð²Ð¾Ð¹ ÑÑ‚Ñ€Ð¾ÐºÐ¸)"></textarea>

<button onclick="install()">INSTALL AI BUILDER</button>

<pre id="log"></pre>

<script>
const logEl=document.getElementById("log");
function log(t){logEl.textContent+=t+"\n";logEl.scrollTop=logEl.scrollHeight;}
function b64(s){return btoa(unescape(encodeURIComponent(s)));}

async function install(){

const gh=document.getElementById("gh").value.trim();
const repo=document.getElementById("repo").value.trim();
const tokens=document.getElementById("tokens").value.trim().split("\n").map(x=>x.trim()).filter(Boolean);
const openrouter=document.getElementById("openrouter").value.trim();
const prompts=document.getElementById("prompts").value.trim().split("\n");

if(!gh||!repo||!tokens.length||!openrouter){
log("Ð—Ð°Ð¿Ð¾Ð»Ð½Ð¸ Ð²ÑÐµ Ð¿Ð¾Ð»Ñ");
return;
}

const headers={
Authorization:`token ${gh}`,
Accept:"application/vnd.github+json",
"Content-Type":"application/json"
};

try{

log("â†’ ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° GitHub...");
const userRes=await fetch("https://api.github.com/user",{headers});
if(!userRes.ok) throw new Error("ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ GitHub Ñ‚Ð¾ÐºÐµÐ½");
const user=await userRes.json();
const username=user.login;
log("âœ“ ÐÐºÐºÐ°ÑƒÐ½Ñ‚: "+username);

await fetch("https://api.github.com/user/repos",{
method:"POST",
headers,
body:JSON.stringify({name:repo,private:false})
});

const repoApi=`https://api.github.com/repos/${username}/${repo}`;

async function upload(path,content){
await fetch(`${repoApi}/contents/${path}`,{
method:"PUT",
headers,
body:JSON.stringify({
message:"deploy "+path,
content:b64(content)
})
});
log("âœ“ "+path);
}

await upload("package.json",JSON.stringify({
type:"module",
dependencies:{ "node-fetch":"^3.3.2" }
},null,2));

await upload("bot.js",`
import fetch from "node-fetch";

const OPENROUTER_KEY = process.env.OPENROUTER_API_KEY;

const BOTS = [
${tokens.map((_,i)=>`{
token: process.env.TELEGRAM_TOKEN_${i+1},
prompt: process.env.SYSTEM_PROMPT_${i+1}
}`).join(",")}
].filter(b=>b.token);

const MAX_RUNTIME = 5.8 * 60 * 60 * 1000;
const startTime = Date.now();

async function aiReply(text, systemPrompt){

const res = await fetch("https://openrouter.ai/api/v1/chat/completions",{
method:"POST",
headers:{
"Content-Type":"application/json",
"Authorization":"Bearer "+OPENROUTER_KEY,
"HTTP-Referer":"https://github.com",
"X-Title":"AI Bot Builder"
},
body:JSON.stringify({
model:"openai/gpt-4o-mini",
messages:[
{role:"system",content:systemPrompt||"You are helpful AI"},
{role:"user",content:text}
]
})
});

const data = await res.json();
return data.choices?.[0]?.message?.content || "AI error";
}

async function runBot(bot){

const api=\`https://api.telegram.org/bot\${bot.token}\`;
let offset=0;

while(true){

if(Date.now()-startTime>MAX_RUNTIME){
process.exit(0);
}

try{

const res=await fetch(\`\${api}/getUpdates?timeout=50&offset=\${offset}\`);
const data=await res.json();

for(const upd of data.result){
offset=upd.update_id+1;

if(upd.message){
const chat=upd.message.chat.id;
const text=upd.message.text||"";

if(text==="/start"){
await fetch(\`\${api}/sendMessage\`,{
method:"POST",
headers:{ "Content-Type":"application/json" },
body:JSON.stringify({chat_id:chat,text:"ðŸš€ AI Builder Active"})
});
}else{
const reply=await aiReply(text,bot.prompt);
await fetch(\`\${api}/sendMessage\`,{
method:"POST",
headers:{ "Content-Type":"application/json" },
body:JSON.stringify({chat_id:chat,text:reply})
});
}
}
}

}catch(e){
await new Promise(r=>setTimeout(r,5000));
}
}
}

for(const bot of BOTS){
runBot(bot);
}
`);

await upload(".github/workflows/bot.yml",`
name: AI Bot Builder
on:
workflow_dispatch:
schedule:
- cron: "*/5 * * * *"
jobs:
run:
runs-on: ubuntu-latest
timeout-minutes: 360
steps:
- uses: actions/checkout@v4
- uses: actions/setup-node@v4
with:
node-version: 20
- run: npm install
- run: node bot.js
env:
${tokens.map((_,i)=>`TELEGRAM_TOKEN_${i+1}: \${{ secrets.TELEGRAM_TOKEN_${i+1} }}
SYSTEM_PROMPT_${i+1}: \${{ secrets.SYSTEM_PROMPT_${i+1} }}`).join("\n")}
OPENROUTER_API_KEY: \${{ secrets.OPENROUTER_API_KEY }}
`);

log("â†’ ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ public key...");
const keyRes=await fetch(`${repoApi}/actions/secrets/public-key`,{headers});
const keyData=await keyRes.json();

function encrypt(secret){
const encoder=new TextEncoder();
const messageBytes=encoder.encode(secret);
const publicKeyBytes=Uint8Array.from(atob(keyData.key),c=>c.charCodeAt(0));
const encryptedBytes=nacl.box.seal(messageBytes,publicKeyBytes);
return btoa(String.fromCharCode(...encryptedBytes));
}

for(let i=0;i<tokens.length;i++){

await fetch(`${repoApi}/actions/secrets/TELEGRAM_TOKEN_${i+1}`,{
method:"PUT",
headers,
body:JSON.stringify({encrypted_value:encrypt(tokens[i]),key_id:keyData.key_id})
});

await fetch(`${repoApi}/actions/secrets/SYSTEM_PROMPT_${i+1}`,{
method:"PUT",
headers,
body:JSON.stringify({encrypted_value:encrypt(prompts[i]||""),key_id:keyData.key_id})
});
}

await fetch(`${repoApi}/actions/secrets/OPENROUTER_API_KEY`,{
method:"PUT",
headers,
body:JSON.stringify({encrypted_value:encrypt(openrouter),key_id:keyData.key_id})
});

log("ðŸ”¥ Ð“ÐžÐ¢ÐžÐ’Ðž.");
log("ÐžÑ‚ÐºÑ€Ð¾Ð¹ Ñ€ÐµÐ¿Ð¾Ð·Ð¸Ñ‚Ð¾Ñ€Ð¸Ð¹ â†’ Actions â†’ Run workflow");

}catch(e){
log("ÐžÑˆÐ¸Ð±ÐºÐ°: "+e.message);
}
}
</script>
</body>
</html>
